#!/usr/bin/env bash

# Fail on any errors, including in pipelines
set -eo pipefail

display_usage() {
    printf "%s\n${WARN}Usage: $0 < function_name >${NC}\n\n"
}

display_make_usage() {
    printf "%s\n${WARN}Usage: make < recipe_name >${NC}\n\n"
}

# The trap_command function runs whenever the script exits
trap_command() {
    local ret="$?"
    set +eo pipefail
    if [[ ! "${SKIP_CLEANUP}" == true ]]; then
        cleanup
    fi
    exit "${ret}"
}

main() {
    local COMMAND="$1"
    local MESSAGE="$2"

    # load libraries
    for f in "$(cd "$(dirname ${BASH_SOURCE[0]})" && pwd)"/make/*; do
        . "$f"
    done

    # Setup shell colors for print/echo statements
    # ${OK}=green, ${WARN}=yellow, ${INFO}=cyan, ${ERR}=red, ${NC}=normal
    setup_colors

    # Check for valid input arguments
    if [[ "$#" -eq 0 ]]; then
        printf "%s\t${ERR}ERROR - script requires input${NC}\n\n" >&2
        display_usage
        exit 1
    elif [[ "${COMMAND}" =~ (help|-h) ]]; then
        display_make_usage
    # Check is the COMMAND var is a valid function or executable script
    elif declare -f "${COMMAND}" &> /dev/null || [[ -x "$COMMAND" ]]; then
        # Trap all signals that cause script to exit & run trap_command function before exiting
        trap 'trap_command' SIGINT SIGTERM ERR EXIT

        # Trap all bash commands & print to screen. Like using set -v but allows printing in color
        set -o functrace
        trap 'printf "%s${INFO}+ $BASH_COMMAND${NC}\n" >&2' DEBUG

        # Activate virtualenv if it exists
        if [[ -f "${VENV_ACTIVATE}" ]]; then
            . "${VENV_ACTIVATE}"
        fi

        "${COMMAND}"
    else
        printf "%s\t${ERR}ERROR - ${COMMAND} is not a valid function or script name ${NC}\n\n" >&2
        display_usage
        exit 1
    fi
}

main "$@"