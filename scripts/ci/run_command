#!/usr/bin/env bash

# Fail on any errors, including in pipelines
set -eo pipefail

function display_usage() {
    printf "%s\n\t${WARN}usage:\t$0 <function_name> <display_message>${NC}\n\n"
}

# The trap_exit function that runs whenever the script exits on error
function trap_command() {
    ret="$?"
    set +eo pipefail
    # Test exit code and print status
    if [[ "${ret}" -eq 0 ]]; then
        printf "%s${MESSAGE}\t[ ${OK} OK ${NC} ]\n" | expand  -t 50
    else
        printf "%s${MESSAGE}\t[ ${ERR} FAILED ${NC} ]\n" | expand  -t 50
    fi
    if [[ ! "${SKIP_CLEANUP}" == true ]]; then
        if [[ "${VERBOSE}" =~ (1|2|true) ]]; then
            cleanup
        else
            cleanup &> /dev/null
        fi
    fi
    exit "${ret}"
}

function main() {
    MESSAGE="$1"
    # drop first argument and set all the following args to the COMMAND var
    COMMAND="${@:2}"

    # load libraries
    for f in "$(cd "$(dirname ${BASH_SOURCE[0]})" && pwd)"/make/*; do
        . "$f"
    done

    # Trap all signals that cause script to exit & run cleanup_error function before exiting
    trap 'trap_command' SIGINT SIGTERM ERR EXIT

    # Check for valid input arguments
    if [[ "$#" -ne 2 ]]; then
        printf "%s\t${ERR}ERROR - script requires 2 inputs.${NC}\n\n" >&2
        display_usage
        exit 1
    # Check is the COMMAND var is a valid function or executable script
    elif declare -f "${COMMAND}" &> /dev/null || [[ -x "$COMMAND" ]]; then
        # Activate virtualenv if it exists
        if [[ -f ${VENV_ACTIVATE} ]]; then
            . "${VENV_ACTIVATE}"
        fi
        printf "%s${MESSAGE}\t[ ${WARN} Processing ${NC} ]\n" | expand  -t 50
        if [[ "${VERBOSE}" == 3 ]]; then
            set -x
            "${COMMAND}"
        elif [[ "${VERBOSE}" == 2 ]]; then
            # Trap all bash commands & print to screen. Like using set -v but allows printing in color
            set -o functrace
            trap 'printf "%s${INFO}+ $BASH_COMMAND${NC}\n" >&2' DEBUG
            "${COMMAND}"
        elif [[ "${VERBOSE}" =~ (true|TRUE|y|Y|1) ]]; then
            "${COMMAND}"
        else
            "${COMMAND}" 2>&1  > /dev/null
        fi
    else
        printf "%s\t${ERR}ERROR - ${COMMAND} is not a valid function or script name ${NC}\n\n" >&2
        display_usage
        exit 1
    fi
}

main "$@"